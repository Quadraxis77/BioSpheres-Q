//! Icosphere mesh generation for WebGPU rendering.
//!
//! This module provides procedural generation of icosphere meshes at various
//! subdivision levels for rendering smooth spherical cells.

use bytemuck::{Pod, Zeroable};
use std::collections::HashMap;

/// Vertex data for an icosphere mesh.
///
/// Layout (24 bytes total):
/// - Offset 0:  position (vec3: x, y, z)
/// - Offset 12: normal (vec3: x, y, z)
#[repr(C)]
#[derive(Copy, Clone, Debug, Pod, Zeroable)]
pub struct IcosphereVertex {
    /// Position on the unit sphere
    pub position: [f32; 3],
    /// Normal vector (equals position for unit sphere at origin)
    pub normal: [f32; 3],
}

impl IcosphereVertex {
    /// Size of the vertex data in bytes
    pub const SIZE: usize = std::mem::size_of::<Self>();

    /// Create a new vertex with position and normal
    pub fn new(position: [f32; 3], normal: [f32; 3]) -> Self {
        Self { position, normal }
    }

    /// Create a vertex on the unit sphere (normal equals position)
    pub fn on_unit_sphere(x: f32, y: f32, z: f32) -> Self {
        let len = (x * x + y * y + z * z).sqrt();
        let nx = x / len;
        let ny = y / len;
        let nz = z / len;
        Self {
            position: [nx, ny, nz],
            normal: [nx, ny, nz],
        }
    }
}

/// An icosphere mesh with vertices and indices.
///
/// The mesh is generated by subdividing an icosahedron and projecting
/// vertices onto the unit sphere.
pub struct IcosphereMesh {
    /// Vertex data (positions and normals)
    pub vertices: Vec<IcosphereVertex>,
    /// Triangle indices (counter-clockwise winding)
    pub indices: Vec<u32>,
}

impl IcosphereMesh {
    /// Calculate the expected vertex count for a given subdivision level.
    ///
    /// Formula: 10 * 4^n + 2 where n is the subdivision level.
    pub fn vertex_count_for_subdivisions(n: u32) -> u32 {
        10 * 4u32.pow(n) + 2
    }

    /// Calculate the expected triangle count for a given subdivision level.
    ///
    /// Formula: 20 * 4^n
    pub fn triangle_count_for_subdivisions(n: u32) -> u32 {
        20 * 4u32.pow(n)
    }

    /// Generate an icosphere mesh with the specified subdivision level.
    ///
    /// - Level 0: 12 vertices, 20 triangles (base icosahedron)
    /// - Level 1: 42 vertices, 80 triangles
    /// - Level 2: 162 vertices, 320 triangles
    /// - Level 3: 642 vertices, 1280 triangles
    /// - Level 4: 2562 vertices, 5120 triangles
    pub fn generate(subdivisions: u32) -> Self {
        let mut generator = IcosphereGenerator::new();
        generator.generate(subdivisions)
    }

    /// Generate an icosphere and create GPU buffers.
    pub fn generate_with_buffers(device: &wgpu::Device, subdivisions: u32) -> IcosphereMeshBuffers {
        let mesh = Self::generate(subdivisions);
        IcosphereMeshBuffers::from_mesh(device, &mesh)
    }
}

/// Icosphere mesh with GPU buffers.
pub struct IcosphereMeshBuffers {
    /// CPU-side vertex data
    pub vertices: Vec<IcosphereVertex>,
    /// CPU-side index data
    pub indices: Vec<u32>,
    /// GPU vertex buffer
    pub vertex_buffer: wgpu::Buffer,
    /// GPU index buffer
    pub index_buffer: wgpu::Buffer,
}

impl IcosphereMeshBuffers {
    /// Create GPU buffers from an existing mesh.
    pub fn from_mesh(device: &wgpu::Device, mesh: &IcosphereMesh) -> Self {
        use wgpu::util::DeviceExt;

        let vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Icosphere Vertex Buffer"),
            contents: bytemuck::cast_slice(&mesh.vertices),
            usage: wgpu::BufferUsages::VERTEX,
        });

        let index_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Icosphere Index Buffer"),
            contents: bytemuck::cast_slice(&mesh.indices),
            usage: wgpu::BufferUsages::INDEX,
        });

        Self {
            vertices: mesh.vertices.clone(),
            indices: mesh.indices.clone(),
            vertex_buffer,
            index_buffer,
        }
    }

    /// Get the number of indices for draw calls.
    pub fn index_count(&self) -> u32 {
        self.indices.len() as u32
    }
}

/// Internal generator for icosphere meshes.
struct IcosphereGenerator {
    vertices: Vec<IcosphereVertex>,
    indices: Vec<u32>,
    /// Cache for midpoint vertices to avoid duplicates during subdivision
    midpoint_cache: HashMap<(u32, u32), u32>,
}

impl IcosphereGenerator {
    fn new() -> Self {
        Self {
            vertices: Vec::new(),
            indices: Vec::new(),
            midpoint_cache: HashMap::new(),
        }
    }

    fn generate(&mut self, subdivisions: u32) -> IcosphereMesh {
        self.create_icosahedron();

        for _ in 0..subdivisions {
            self.subdivide();
        }

        IcosphereMesh {
            vertices: std::mem::take(&mut self.vertices),
            indices: std::mem::take(&mut self.indices),
        }
    }

    /// Create the base icosahedron (12 vertices, 20 triangles).
    fn create_icosahedron(&mut self) {
        // Golden ratio
        let phi = (1.0 + 5.0_f32.sqrt()) / 2.0;

        // 12 vertices of an icosahedron
        // The vertices are arranged on 3 orthogonal golden rectangles
        let raw_vertices = [
            (-1.0, phi, 0.0),
            (1.0, phi, 0.0),
            (-1.0, -phi, 0.0),
            (1.0, -phi, 0.0),
            (0.0, -1.0, phi),
            (0.0, 1.0, phi),
            (0.0, -1.0, -phi),
            (0.0, 1.0, -phi),
            (phi, 0.0, -1.0),
            (phi, 0.0, 1.0),
            (-phi, 0.0, -1.0),
            (-phi, 0.0, 1.0),
        ];

        // Add vertices normalized to unit sphere
        for (x, y, z) in raw_vertices {
            self.vertices.push(IcosphereVertex::on_unit_sphere(x, y, z));
        }

        // 20 triangles of the icosahedron
        // Winding order is counter-clockwise when viewed from outside
        let triangles = [
            // 5 faces around point 0
            (0, 11, 5),
            (0, 5, 1),
            (0, 1, 7),
            (0, 7, 10),
            (0, 10, 11),
            // 5 adjacent faces
            (1, 5, 9),
            (5, 11, 4),
            (11, 10, 2),
            (10, 7, 6),
            (7, 1, 8),
            // 5 faces around point 3
            (3, 9, 4),
            (3, 4, 2),
            (3, 2, 6),
            (3, 6, 8),
            (3, 8, 9),
            // 5 adjacent faces
            (4, 9, 5),
            (2, 4, 11),
            (6, 2, 10),
            (8, 6, 7),
            (9, 8, 1),
        ];

        for (a, b, c) in triangles {
            self.indices.push(a);
            self.indices.push(b);
            self.indices.push(c);
        }
    }

    /// Subdivide all triangles by splitting each edge at the midpoint.
    fn subdivide(&mut self) {
        self.midpoint_cache.clear();
        let old_indices = std::mem::take(&mut self.indices);

        // Process triangles in groups of 3 indices
        for chunk in old_indices.chunks(3) {
            let v0 = chunk[0];
            let v1 = chunk[1];
            let v2 = chunk[2];

            // Get or create midpoint vertices
            let a = self.get_midpoint(v0, v1);
            let b = self.get_midpoint(v1, v2);
            let c = self.get_midpoint(v2, v0);

            // Create 4 new triangles from the original
            // Maintain counter-clockwise winding order
            self.indices.extend_from_slice(&[v0, a, c]);
            self.indices.extend_from_slice(&[v1, b, a]);
            self.indices.extend_from_slice(&[v2, c, b]);
            self.indices.extend_from_slice(&[a, b, c]);
        }
    }

    /// Get or create a midpoint vertex between two vertices.
    fn get_midpoint(&mut self, v0: u32, v1: u32) -> u32 {
        // Use ordered pair as key to ensure consistency
        let key = if v0 < v1 { (v0, v1) } else { (v1, v0) };

        if let Some(&index) = self.midpoint_cache.get(&key) {
            return index;
        }

        // Calculate midpoint and normalize to unit sphere
        let p0 = &self.vertices[v0 as usize];
        let p1 = &self.vertices[v1 as usize];

        let mx = (p0.position[0] + p1.position[0]) / 2.0;
        let my = (p0.position[1] + p1.position[1]) / 2.0;
        let mz = (p0.position[2] + p1.position[2]) / 2.0;

        let new_vertex = IcosphereVertex::on_unit_sphere(mx, my, mz);
        let new_index = self.vertices.len() as u32;
        self.vertices.push(new_vertex);

        self.midpoint_cache.insert(key, new_index);
        new_index
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vertex_size() {
        assert_eq!(IcosphereVertex::SIZE, 24);
    }

    #[test]
    fn test_vertex_on_unit_sphere() {
        let v = IcosphereVertex::on_unit_sphere(1.0, 1.0, 1.0);
        let len = (v.position[0].powi(2) + v.position[1].powi(2) + v.position[2].powi(2)).sqrt();
        assert!((len - 1.0).abs() < 1e-6);
        assert_eq!(v.position, v.normal);
    }

    #[test]
    fn test_base_icosahedron() {
        let mesh = IcosphereMesh::generate(0);
        assert_eq!(mesh.vertices.len(), 12);
        assert_eq!(mesh.indices.len(), 60); // 20 triangles * 3 indices
    }

    #[test]
    fn test_vertex_count_formula() {
        // Level 0: 10 * 4^0 + 2 = 12
        assert_eq!(IcosphereMesh::vertex_count_for_subdivisions(0), 12);
        // Level 1: 10 * 4^1 + 2 = 42
        assert_eq!(IcosphereMesh::vertex_count_for_subdivisions(1), 42);
        // Level 2: 10 * 4^2 + 2 = 162
        assert_eq!(IcosphereMesh::vertex_count_for_subdivisions(2), 162);
        // Level 3: 10 * 4^3 + 2 = 642
        assert_eq!(IcosphereMesh::vertex_count_for_subdivisions(3), 642);
    }

    #[test]
    fn test_generated_vertex_count_matches_formula() {
        for n in 0..=4 {
            let mesh = IcosphereMesh::generate(n);
            let expected = IcosphereMesh::vertex_count_for_subdivisions(n) as usize;
            assert_eq!(
                mesh.vertices.len(),
                expected,
                "Subdivision level {} should have {} vertices, got {}",
                n,
                expected,
                mesh.vertices.len()
            );
        }
    }

    #[test]
    fn test_triangle_count_formula() {
        for n in 0..=4 {
            let mesh = IcosphereMesh::generate(n);
            let expected_triangles = IcosphereMesh::triangle_count_for_subdivisions(n) as usize;
            let actual_triangles = mesh.indices.len() / 3;
            assert_eq!(
                actual_triangles, expected_triangles,
                "Subdivision level {} should have {} triangles, got {}",
                n, expected_triangles, actual_triangles
            );
        }
    }

    #[test]
    fn test_all_vertices_on_unit_sphere() {
        let mesh = IcosphereMesh::generate(2);
        for (i, v) in mesh.vertices.iter().enumerate() {
            let len =
                (v.position[0].powi(2) + v.position[1].powi(2) + v.position[2].powi(2)).sqrt();
            assert!(
                (len - 1.0).abs() < 1e-5,
                "Vertex {} has length {}, expected 1.0",
                i,
                len
            );
        }
    }

    #[test]
    fn test_normals_equal_positions() {
        let mesh = IcosphereMesh::generate(2);
        for (i, v) in mesh.vertices.iter().enumerate() {
            assert_eq!(
                v.position, v.normal,
                "Vertex {} normal {:?} should equal position {:?}",
                i, v.normal, v.position
            );
        }
    }

    #[test]
    fn test_valid_indices() {
        let mesh = IcosphereMesh::generate(2);
        let vertex_count = mesh.vertices.len() as u32;
        for (i, &index) in mesh.indices.iter().enumerate() {
            assert!(
                index < vertex_count,
                "Index {} at position {} is out of bounds (vertex count: {})",
                index,
                i,
                vertex_count
            );
        }
    }
}
